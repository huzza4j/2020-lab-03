#### Chapter 1: 优秀测试的承诺

- **双稳态定律**: 编写测试的最大价值不在于结果,而在于编写过程中的学习;把测试看做质量保证工具是质量稳态,但是并不能发挥测试的
全部潜力;而第二稳态就是把测试作为设计工具的稳态,这样才能最大化利用测试的潜力,以测试驱动设计

- **TDD**: Test Driven Development,测试先于编程,测试驱动开发

- **BDD**: Behavior Driven Development,行为驱动开发


---
#### Chapter 2: 寻求优秀

- **可读的代码才是可维护的代码**: 难以阅读和理解的测试就会带来维护问题

- **结构有助于理解事物**: 将大的函数切割成小的函数,同时也不能过度分解适得其反,以领域和抽象为边界;多大的测试用例执行
费时,当出现bug反馈时间长,导致生产率低下;良好的结构有助于快速定位到正确的位置

- **测试的命名**: 测试用例要表明测试正确的逻辑,同样是可读性的问题

- **测试类之间不要相互依赖**: 如测试顺序

- 三个基本工具: **测试框架,构建工具,测试替身**


---
#### Chapter 3: 测试替身

##### Chapter 3-1: 替身作用

- **隔离被测试代码**: 被测试的代码,与测试代码交互的代码(隔离);使测试易理解,具有针对性,同时更加容易建立测试

- **加速执行测试**: 减少了依赖相关的初始化等逻辑消耗时间

- **使执行变得确定**: 精确控制测试场景中的所有依赖变量,使执行变得符合预期,减少随机元素

- **模拟特殊情况**: 利用替身模拟一些正常不会出现的特殊场景

- **暴露隐藏的信息**: 不是允许测试访问对象的私有属性,而是通过替身代替私有对象,同时防止为了测试而改动生产代码如:
```java
public class Car{
 private Engine engine;

 public void start(){
   engine.start();
 }
}
// 当汽车启动,怎么测试engine也是启动的;可以把私有对象engine开放,同时添加一个方法去判断,但是这样就仅仅为测试添加了
// 无用的功能,还有一种做法就是利用替身,在测试环境添加如下:
public class CarTest {
  @Test
  public void engineIsStartedWhenCarStarts() {
    TestEngine engine  = new TestEngine();
    new Car(engine).start();
    assertTrue(engine.isRunning());
 }
}
public class TestEngine extends Engine {
  private boolean isRunning;

  public void start() {
    isRunning = true;
 }
  public boolean isRunning() {
    return isRunning;
 }
}
```
##### Chapter 3-2: 替身类型

- **测试桩(Stub)**: 桩,截断的非常短的物体,测试桩就是用最简单的实现代替真实对象的实现;通常什么都不做,或者硬编码返回内容

- **伪造对象(Fake)**: 伪造对象,是一种更加复杂的测试替身,因为stub总是硬编码返回值,当每个测试需要有差异的返回不同值,
用以模拟不同的场景,就需要fake对象;如Repo是直接访问数据库的,可以通过打桩使其返回所需内容,但是复杂的场景肯定越发复杂,可以
同一个简单的内存数据库,实现Fake持久化测试

- **测试间谍(Spy)**: 当没有对象作为参数传入时,通过它们的api也能揭示要了解的知识(手动使它们记录,事后询问),相当于记录
过去发生的情况,便于测试在后续校对

- **模拟对象(Mock)**: 模拟对象是特殊的spy,特定环境下可以配置我们需要的行为;通常使用JMock,Mockito,EasyMock


##### Chapter 3-3: 替身指南 

- **Stub管查询,Mock管操作**: 当写出来的测试代码比较糟糕,可以考虑使用伪造对象Fake

- **Give-When-Then**: 行为驱动推广的也就是我们测试编码的一种约定,首先是准备要协作的对象,然后对其调用,最后进行断言
或许准备阶段的mock设置期望值也是一直断言,同时注意编码期间三段式之间空行保留空白有助于阅读

- **检查行为,而非实现**: 一个测试应当只测试一件事情,并且好好地测试;不应该过度的对所有对象mock,同时对mock对象设置过度细致的期望

- **框架选择**: 建议是旧代码添加测试使用Mockito(替身允许你在任何时候嗲用任何方法),新功能使用JMock(替身期望你不会再任何时候调用任何方法)

- **依赖注入**: 建议不要在同一个地方实例化使用测试替身,最好是从外部将依赖传递给对象,通常是使用构造函数注入;提高可测性


---
#### Chapter 4: 可读性 (Code Smell)

- 基本断言的Smell: 注意断言的抽象层次,避免无意义的单词和数字使用
  - assertThat | assertTrue | assertFalse | assertEquals
  
- 过度断言的Smell: 类似于单一职责(一个类应该有且只有一个改变的理由),而一个测试应该只有一个失败的原因,而过度细致的
断言或者断言范围太宽,会导致测试脆肉很容易被破坏,同时破坏测试的细节或许是无关因素,但是却需要花时间查看这些细节,最终才能
找出发生了什么变化破坏了测试;

